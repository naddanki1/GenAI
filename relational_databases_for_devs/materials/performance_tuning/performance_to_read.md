
# Performance tuning

### Table of Contents

<!-- TOC -->
* [Your Goals](#your-goals)
* [What is Performance Tuning](#what-is-performance-tuning)
* [Best Practices For Designing An Efficient Database](#best-practices-for-designing-an-efficient-database)
* [Partition](#partition)
* [Query Optimization Tips and Tricks](#query-optimization-tips-and-tricks)
<!-- TOC -->

### Your Goals

-   Understand what performance tuning is and its importance in SQL
-   Learn about important things to keep in mind when optimizing SQL code
-   Understand best practices for designing an efficient database, such as normalization, indexing, choosing appropriate data types, and avoiding unnecessary data retrieval
-   Learn about partitioning, including types of partitioning, when and how to use partitioning, and best cases for using partitioning
-   Learn about query optimization tips and tricks, such as the differences between DISTINCT and GROUP BY, OR operator vs UNION vs IN() vs ANY(VALUES()), HAVING vs WHERE
-   Be able to apply these concepts to improve the performance of your SQL code.
---


###  What is Performance Tuning

__Performance tuning__ in SQL is the process of optimizing the performance of SQL queries and database operations to increase their efficiency and speed. This is important for systems that rely on a large volume of data and a high number of queries. By optimizing the performance of SQL code, you can improve the overall performance of the system and reduce the load on the database server.

Performance tuning in SQL involves understanding how the database server processes queries and how the system is configured. It involves analyzing the SQL queries and identifying bottlenecks that slow down the performance. Some important things to consider when performance tuning SQL code include:

-   Indexes: Proper use of indexes can greatly improve the performance of queries by reducing the number of rows that need to be scanned.
-   Partitioning: Partitioning large tables can improve the performance of queries by allowing the database server to retrieve and manipulate data more efficiently.
-   Query optimization: Optimizing SQL queries can improve the performance by reducing the number of rows that need to be scanned and increasing the efficiency of the query.
-   Data types: Selecting appropriate data types and sizes can reduce the amount of memory used and improve the performance of queries.
-   To improve the performance, you should monitor and analyze the performance of the system, understand the database server's architecture, and optimize the SQL queries and database operations.

It's important to mention that performance tuning is an ongoing process, and it's always a good practice to monitor and analyze the performance of the system, and make adjustments as needed.

Please keep in mind that these are general guidelines and the performance may vary depending on the specific requirements of the application and the data.

### EXPLAIN and EXPLAIN ANALYZE

__Explain__ and __Explain Analyze__ are two important statements used in SQL to understand how the database server executes a query. These statements help in analyzing the performance of a query and identifying any bottlenecks that might be causing the query to slow down. Understanding how these statements work and when to use them is crucial for optimizing the performance of your queries.

THE "__EXPLAIN__" statement is used to show the execution plan that the database server uses to execute a query. The execution plan shows the steps that the server will take to retrieve the requested data, such as which indexes it will use, how it will join tables, and so on.

On the other hand, the "__EXPLAIN ANALYZE__" statement is similar to "__EXPLAIN__", but it actually runs the query and includes information about the time and resources that the query used. This can be useful for identifying performance bottlenecks in your queries and optimizing them accordingly.

It is recommended to use the __EXPLAIN__ statement when you want to understand how the database server is executing a query and identify any potential performance bottlenecks. You should use the __EXPLAIN ANALYZE__ statement when you want to understand the actual performance of a query and identify any specific areas where the query is taking a lot of time or resources.

It's important to note that the execution plan generated by **the explain analyze statement may change depending on the current state of the database**, such as the amount of data present in the tables, the values of the parameters passed to the query, etc.

Here is an example of how you might use the __EXPLAIN__ statement using PostgreSQL syntax:
```sql
-- Use EXPLAIN to show the execution plan for a query
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;
```
Here is an example of the output you might see when running the __EXPLAIN query__:
```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;
                                              QUERY PLAN                                                    
---------------------------------------------------------------------------
 Index Scan using orders_customer_id_index on orders  
 (cost=0.29..8.31 rows=1 width=46)
 Index Cond: (customer_id = 123)
 (2 rows)
```
This output shows the execution plan used by the database server to execute the query. It shows that the server is using an index scan on the "orders" table using the "orders_customer_id_index" index, and that it is only returning 1 row of data that matches the condition "customer_id = 123".

Here is an example of how you might use the __EXPLAIN ANALYZE__ statement using PostgreSQL syntax:
```sql
-- Use EXPLAIN ANALYZE to show the execution plan 
-- and performance statistics for a query
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;
```
Here is an example of the output you might see when running the __EXPLAIN ANALYZE__ query:
```sql
EXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;
                                                               QUERY PLAN                                                                      
---------------------------------------------------------------------------
 Index Scan using orders_customer_id_index on orders  
 (cost=0.29..8.31 rows=1 width=46) 
 (actual time=0.013..0.013 rows=1 loops=1)
 Index Cond: (customer_id = 123)
 Planning Time: 0.099 ms
 Execution Time: 0.017 ms
 (3 rows)
```
This output shows the same execution plan as the previous example, but it also includes additional information about the time and resources used to execute the query. It shows that the server spent 0.013ms to execute the query and it returned 1 row.

Note that the values of the time and resources consumed may vary based on your database, tables, and query.

### Best Practices For Designing An Efficient Database

__Designing an efficient database__ schema is crucial for ensuring that your queries perform well. A well-designed schema can make a big difference in the performance of your queries, especially when working with large amounts of data.

Here are a few best practices for designing efficient database schemas:

-   __Normalize your data__: Normalization is the process of organizing data into separate tables in order to reduce data redundancy and improve data integrity. Normalizing your data can help to minimize the number of joins required in your queries, which can improve performance.
    
-   __Use appropriate data types__: Using the appropriate data types can help to minimize the amount of memory and disk space required to store your data, which can improve performance. For example, using a smaller data type like a TINYINT instead of an INT for a column that only stores small values can save space and improve performance.
    
-   __Use indexes wisely__: Indexes can greatly improve the performance of your queries, but they can also **slow down writes to the database**. Be sure to use indexes wisely and only create indexes for columns that are frequently used in WHERE clauses.
    
-   __Avoid unnecessary data retrieval__: Retrieving more data than necessary can slow down your queries and consume unnecessary resources. Be sure to only retrieve the columns and rows that you need for a particular query. 

Here is an example of an __efficient database schema__ for an e-commerce application:

```sql
CREATE TABLE IF NOT EXISTS customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL
);

CREATE TABLE IF NOT EXISTS orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL REFERENCES customers(customer_id),
    order_date TIMESTAMP NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL
);

CREATE TABLE IF NOT EXISTS order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES orders(order_id),
    product_id INTEGER NOT NULL REFERENCES products(product_id),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL
);
```
This schema is an example of a normalized schema, where the data is separated into separate tables for customers, orders, and order items. The primary key and foreign key constraints have been used to ensure data integrity and to minimize the number of joins required in queries.

For example, to retrieve all orders for a customer, you can use the following query:
```sql
SELECT * FROM orders
WHERE customer_id = 123;
```
This query uses the customer_id column in the WHERE clause, so an index can be created on this column for faster retrieval.

__Selecting the appropriate data types and indexes__ is crucial for ensuring that your queries perform well. Using the wrong data types or missing indexes can slow down your queries and consume unnecessary resources.

Here are a few best practices for selecting the appropriate data types and indexes:

-   __Use the smallest data type that can hold the values you need__. For example, use a TINYINT instead of INT for a column that only stores small values.
    
-   __Use indexes for columns that are frequently used in WHERE clauses and JOIN conditions__. For example, if you frequently use a column in a WHERE clause to filter data, such as a customer_id column in an orders table, you should create an index on that column to improve query performance.

-   __Use clustered indexes for columns that are frequently used for sorting and ordering data__. A clustered index determines the physical order of data in a table, so if you frequently use a column to sort data, such as an order_date column in an orders table, you should create a clustered index on that column.
    
-   __Use full-text indexes for columns that are frequently used for text search__. Full-text indexes can greatly improve the performance of text search queries, so if you frequently use a column to search for text, such as a product_name column in a products table, you should create a full-text index on that column.

Here is an example of selecting the appropriate data types and indexes:
```sql
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    stock_quantity INTEGER NOT NULL
);
```
In this example, the product_id column uses the SERIAL data type, which is an auto-incrementing integer. This is appropriate for a primary key column that will be used to uniquely identify rows in the table.

The price column uses the DECIMAL data type, which is appropriate for storing decimal values. The stock_quantity column uses the INTEGER data type, which is appropriate for storing integers.

For this table, you can create an index on the product_name column to improve the performance of text search queries like the following:
```sql
SELECT * FROM products WHERE product_name LIKE 'iphone%';
```


__Retrieving more data than necessary__ can slow down your queries and consume unnecessary resources. To avoid unnecessary data retrieval, you should be sure to only retrieve the columns and rows that you need for a particular query.

Here are a few best practices for avoiding unnecessary data retrieval:

-   Use the SELECT statement to specify the columns that you need to retrieve.
    
-   Use the WHERE clause to specify the rows that you need to retrieve.
    
-   Use the LIMIT clause to limit the number of rows that you retrieve.
    

6.  Examples of avoiding unnecessary data retrieval with tables and queries

Here is an example of avoiding unnecessary data retrieval:
```sql
SELECT first_name, last_name FROM customers WHERE customer_id = 123;
```
In this example, only the first_name and last_name columns are retrieved, and only the row with a customer_id of 123 is retrieved. This avoids unnecessary data retrieval and improves query performance.

Another example would be when you don't need all the rows retrieved, you can use the LIMIT clause like the following:
```sql
SELECT * FROM orders LIMIT 10;
```
This query will retrieve only the first 10 rows from the orders table, avoiding unnecessary data retrieval for the remaining rows.


### Partition 

In SQL, __partitioning__ is a technique used to split a large table into smaller, more manageable pieces called partitions. Each partition is a subset of the table's data and can be stored and accessed separately. Partitioning can be done based on different criteria such as range, list, and hash, each with its own advantages and disadvantages.

Partitioning is typically used for large tables that have a high volume of data and a large number of queries. It can improve the performance of queries by allowing the database server to retrieve and manipulate data more efficiently.

Partitioning can be done in several ways:

1.  __Range partitioning__: In this type of partitioning, data is divided into partitions based on a range of values in a particular column. For example, you could partition a table of orders by the order date, with one partition for orders placed in the first quarter of the year, another partition for orders placed in the second quarter, and so on. This allows the database server to quickly retrieve and manipulate data within a specific range of values.

	Here is an example of __range partitioning__ in SQL:
	```sql
	CREATE TABLE orders (
	    order_id INTEGER NOT NULL,
	    order_date DATE NOT NULL,
	    customer_id INTEGER NOT NULL,
	    total_amount DECIMAL(10, 2) NOT NULL
	)
	PARTITION BY RANGE (order_date)
	(
	    PARTITION p0 VALUES LESS THAN ('2020-01-01'),
	    PARTITION p1 VALUES LESS THAN ('2020-06-01'),
	    PARTITION p2 VALUES LESS THAN ('2020-12-01'),
	    PARTITION p3 VALUES LESS THAN (MAXVALUE)
	);
	```
	In this example, the orders table is partitioned based on the order_date column using range partitioning. The table is divided into four partitions: p0, p1, p2, and p3. Each partition contains a range of order dates.
    
2.  __List partitioning__: In this type of partitioning, data is divided into partitions based on a list of values in a particular column. For example, you could partition a table of customers by city, with one partition for customers from Boston, another partition for customers from New York, and so on. This allows the database server to quickly retrieve and manipulate data based on a specific list of values.

	Here is an example of __list partitioning__ in SQL:
	```sql
	CREATE TABLE customers (
	    customer_id INTEGER NOT NULL, 
	    first_name VARCHAR(255) NOT NULL, 
	    last_name VARCHAR(255) NOT NULL, 
	    city VARCHAR(255) NOT NULL 
	    ) 
	    PARTITION BY LIST (city) 
	    (
	    PARTITION p_east VALUES ('Boston', 'New York', 'Philadelphia'), 
	    PARTITION p_west VALUES ('Los Angeles', 'San Francisco', 'Seattle'),
	    PARTITION p_other VALUES (DEFAULT)  		     
	    );

	```
    
3.  __Hash partitioning__: In this type of partitioning, data is divided into partitions based on a hash function applied to a particular column. The hash function maps the values of the column to a specific partition. This allows the database server to evenly distribute data across partitions and quickly retrieve and manipulate data based on the value of the column.

	Here is an example of __hash partitioning__ in SQL:
	```sql
	CREATE TABLE sales (
	    sales_id INTEGER NOT NULL,
	    product_id INTEGER NOT NULL,
	    quantity INTEGER NOT NULL,
	    sale_date DATE NOT NULL
	)
	PARTITION BY HASH (product_id)
	PARTITIONS 4;
	```
	In this example, the sales table is partitioned based on the product_id column using hash partitioning. The table is divided into 4 partitions. The partitioning is done by a Hash function which assigns a specific partition to each value of the product_id column.

	You can also specify a different number of partitions according to your requirements, for example if you want to have 8 partitions, you can change the last line to :
	```sql
	PARTITIONS 8;
	```

	The choice of partitioning method to use depends on the specific requirements of the application and the data. Please keep in mind that not all RDBMS support all types of partitioning, and the syntax and options may vary.

Here are some of the __best use cases for partitioning__ in SQL:

1.  __Large tables__: Partitioning is particularly useful for large tables that have a high volume of data and a large number of queries. It can improve the performance of queries by allowing the database server to retrieve and manipulate data more efficiently.
    
2.  __Queries that filter data based on a specific column__: Partitioning a table based on a specific column can help to reduce the number of rows that need to be scanned, thus improving the performance of these queries. For example, if you have a table of orders and most of your queries filter data based on the order date, partitioning the table by the order date can improve the performance of these queries.
    
3.  __Data that is written once and read many times__: Partitioning the table based on the date of the data will help you to archive older data in a separate partition and improve the performance for the current data.
    
4.  __Backup and recovery__: Partitioning allows you to perform maintenance operations, such as backups and archiving, on specific partitions rather than the entire table. This can be more efficient and less disruptive than performing these operations on an entire table.
    
5.  __High availability__: Partitioning allows you to distribute data across multiple servers and improve the availability of the data. This can be useful for systems that require high availability and can tolerate some data loss in case of a failure.
    
6.  __Data warehousing and reporting__: Partitioning can help to improve the performance of data warehousing and reporting systems by allowing them to retrieve and manipulate data more efficiently.
    
Please keep in mind that these are general use cases, and the specific implementation and benefits of partitioning may vary depending on the specific requirements of the application and the data.

### Query Optimization Tips and Tricks

#### GROUP BY vs DISTINCT when eliminating duplicates:

Both GROUP BY and DISTINCT are used to eliminate duplicates from the result set, but they do it in different ways. GROUP BY groups the rows and then applies aggregate functions to the groups, while DISTINCT eliminates duplicates before returning the result set.

While DISTINCT is more explicit in it's purpose, and GROUP BY appears to only be necessary when utilizing aggregations, they are often interchangeable. It is important to evaluate the performance of each when eliminating duplicates and choose the one that performs better for your specific scenario. Remember to examine the performance of their usage.

In terms of performance, DISTINCT may be faster when the number of duplicates is high and the result set is small. However, when the result set is large and/or the number of duplicates is low, GROUP BY may be faster as it allows the use of indexes and it can return more information by applying aggregate functions.

When you use GROUP BY, the query planner can use indexes to group the data. In contrast, when you use DISTINCT, the query planner must perform a sort operation to eliminate duplicates, which can be slower. If your table has a unique index or a primary key, the query planner will use this index to eliminate duplicates instead of sorting the data.

It is always a good idea to test the performance of your queries by running EXPLAIN or EXPLAIN ANALYZE to see the execution plan and the number of rows that are scanned.

#### Try not to use 'OR operator' in the WHERE clause:

The main point is that it is generally best to avoid using the OR operator in the WHERE clause because it can negatively impact performance.

In general, When the OR operator is used in a query, the query planner can use a bitmap index scan to quickly find the matching rows.

A bitmap index scan creates a bitmap for each indexed column in the OR clause and then combines the bitmaps using a bitwise OR operation. This can be more efficient than performing a full table scan or using multiple index scans.

However, bitmap index scans can be more expensive than normal index scans, since they have to build the bitmap. Additionally, they use more RAM. The query planner will evaluate the cost of each possible execution plan and choose the one with the lowest cost.

It's important to note that bitmap index scans are not always the best choice, and it depends on the specific requirements of the application and the data. The query planner uses a cost-based optimization algorithm to choose the execution plan and it takes into account multiple factors such as the number of rows, the selectivity of the conditions, the availability of indexes, etc.

1. __OR Operator vs IN()__:
The OR operator is used to combine multiple conditions in a query, while the IN() operator is used to check if a value is present in a list of values. The OR operator can be slower than the IN() operator because it requires the database server to check all conditions.

	In terms of performance, __using the IN() operator is generally more efficient than using the OR operator__ because it checks if a value is present in a list of values or a subquery, which is usually faster than checking multiple conditions. When you use IN() operator, the query planner can use indexes to search the values. In contrast, when you use OR operator, the query planner must perform a bitmap scan operation to check the conditions. Bitmap scan is more expensive than normal index scan because it creates a bitmap of matching rows and then scans the bitmap to find the matching rows.

	An example when using IN() operator is better than OR operator is when you want to check if a value matches any of a fixed set of values.

	For example, let's say you have a table called "orders" with a column called "status" that can have one of the following values: 'pending', 'shipped', 'delivered', 'cancelled'.

	If you want to retrieve all orders with status 'pending' or 'shipped', you can use the IN() operator as follows:
	```sql
	SELECT * 
	FROM orders 
	WHERE status IN ('pending', 'shipped');
	```
	This query uses the IN() operator to check if the value of the column 'status' is any of the values in the list ('pending', 'shipped'). Using the IN() operator is more efficient than using the OR operator because it allows the query planner to use indexes if they exist on the column 'status'.

	On the other hand, if you use OR operator in this case, the query planner needs to evaluate each condition separately which can lead to slower performance:
	```sql
	SELECT * 
	FROM orders 
	WHERE status = 'pending' OR status = 'shipped';
	```
	Additionally, using IN() operator is more readable than using OR operator in this case.

2. __OR Operator vs ANY(VALUES())__:

	Another case where using ANY (VALUES) is better than using OR operator is when you want to check if a value matches any of a fixed set of values and you also have an index on that column. The ANY (VALUES) operator allows the query planner to make full use of any primary key index or unique index on the column, which can be more efficient than using the OR operator.

	For example, let's say you have a table called "orders" with a column called "order_id" that is the primary key and you want to retrieve all orders with specific order_ids (1,2,3,4)
	```sql
	SELECT * 
	FROM orders 
	WHERE order_id = ANY (VALUES (1), (2), (3), (4));
	``` 

	This query uses the ANY (VALUES) operator to check if the value of the column 'order_id' is any of the values in the list (1,2,3,4). Using the ANY (VALUES) operator allows the query planner to make full use of the primary key index on the 'order_id' column, which can be more efficient than using the OR operator in this case.

	```sql
	SELECT * 
	FROM orders 
	WHERE order_id = 1 OR order_id = 2 OR order_id = 3 OR order_id = 4;
	```
	Also, using ANY(VALUES()) is more readable than using OR operator in this case.

3. __OR operator vs UNION__:

	Using UNION operator can be an alternative to using OR operator when you want to combine conditions from different tables.

	The UNION operator combines the results of two or more SELECT statements into a single result set. It eliminates duplicate rows from the final result set.

	For example, let's say you have two tables: orders and order_items. You want to retrieve all orders with a specific status and all orders that contain a specific product. Instead of using the OR operator to combine the conditions from the two tables, you can use UNION as follows:

	```sql
	SELECT * FROM orders WHERE status = 'shipped'
	UNION
	SELECT * 
	FROM order_items 
	JOIN orders 
	ON order_items.order_id = orders.order_id 
	WHERE product_id = 5;
	```

	This query retrieves all rows from the orders table where status = 'shipped' and all rows from the order_items table where product_id = 5 and join them to the orders table on order_id. Using UNION can be more efficient than using OR operator in this case, because it allows the query planner to use indexes if they exist on the column 'status' and 'product_id'

	It's important to note that, UNION is slower than UNION ALL, because it eliminates duplicate rows.

#### HAVING vs WHERE:

The main point is that __HAVING is less efficient than WHERE__ because it only filters the results after accessing and hashing the rows. __However, In certain cases, HAVING is more efficient than WHILE__. it's important to examine what you plan to filter in the WHERE clause, particularly when using aggregate functions.

An example when a WHERE condition is creating more expensive unnecessary operations than a HAVING condition would be when you are filtering a large result set based on the results of an aggregate function.

For example, consider a table 'orders' with a million rows and you want to retrieve the total number of orders for each product and filter the results only for products that have more than 10 orders.
```sql
SELECT product_id, COUNT(*) as total_orders
FROM orders
WHERE (SELECT COUNT(*) FROM orders WHERE product_id = o.product_id) > 10
GROUP BY product_id;
``` 

In this query, the subquery in the WHERE condition will be executed for each row, which can be very slow and expensive.

On the other hand, the same query can be written using a HAVING condition:
```sql
SELECT product_id, COUNT(*) as total_orders
FROM orders
GROUP BY product_id
HAVING COUNT(*) > 10;
```

In this query, the HAVING condition filters the groups of rows returned by the GROUP BY statement, which is generally faster and more efficient.

You can use EXPLAIN ANALYZE to compare the performance of the two queries.

```sql
EXPLAIN ANALYZE SELECT product_id, COUNT(*) as total_orders 
FROM orders 
WHERE (SELECT COUNT(*) FROM orders WHERE product_id = o.product_id) > 10 
GROUP BY product_id;
```

And

```sql
EXPLAIN ANALYZE SELECT product_id, COUNT(*) as total_orders 
FROM orders 
GROUP BY product_id 
HAVING COUNT(*) > 10;
```

You will notice that the first query takes more time and scans more rows than the second query which is more efficient.







